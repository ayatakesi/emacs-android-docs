
このディレクトリーにはさまざまな異なる種類のAndroidマシンを意図した、複数のインストール用パッケージがある。


emacs-3*.0.*0-16-armeabi-v7a.apk - armv7 devices running Android 4.1 or later.
emacs-3*.0.*0-24-armeabi-v7a.apk - armv7 devices running Android 7.0 or later.
emacs-3*.0.*0-21-arm64-v8a.apk - aarch64 devices running Android 5.0 or later.
emacs-3*.0.*0-29-arm64-v8a.apk - aarch64 devices running Android 10.0 or later.
emacs-3*.0.*0-21-mips64.apk - mips64 devices running Android 5.0 or later.
emacs-3*.0.*0-21-x86_64.apk - x86_64 devices running Android 5.0 or later.
emacs-3*.0.*0-29-x86_64.apk - x86_64 devices running Android 10.0 or later.
emacs-3*.0.*0-9-armeabi.apk - armeabi devices running Android 2.3 or later.
emacs-3*.0.*0-9-mips.apk - mips devices running Android 2.3 or later.
emacs-3*.0.*0-9-x86.apk	- x86 devices running Android 2.3 or later.
emacs-3*.0.*0-8-armeabi.apk - armeabi devices running Android 2.2.


如何なる時もあなたのAndroidシステムが使用しているCPU向けパッケージをインストールすること。他のシステムと互換性のあるパッケージ(たとえばx86_64システムにx86パッケージをインストールするなど)をインストールすると、サブプロセスの実行に失敗するだろう。


上記に加えてディレクトリー`termux`には`shared user
ID`を`com.termux`にセットしてビルド、さらにEmacsの署名キーで署名したバージョンのTermux端末エミュレータのインストール様パッケージのコピーが含まれている。これらのパッケージを合わせるとTermuxのパッケージレポジトリ使用できるEmacsが利用可能になる。


Termuxサポート付きEmacsをインストールするためには、署名やユーザーIDの競合を防ぐためにまず既存のEmacsとTermuxのコピーをすべて削除する必要がある(Emacsのホームディレクトリー内のすべてのデータが削除されるので事前にバックアップすること!)。次は
**最初に**
Termux、その後にEmacs話インストールする。一度これらのパッケージを両方インストールしたらTermuxをオープンして、表示されたシェルプロンプトで以下をタイプする:


$ pkg update && pkg upgrade


dpkgパッケージマネージャーが求める確認には同意していく。すべてのアプリケーションがインストールされて更新されたら、Emacsをオープンして以下のコードを`early-init.el`に記述する:
(setenv "PATH" (format "%s:%s" "/data/data/com.termux/files/usr/bin"
               (getenv "PATH")))
(push "/data/data/com.termux/files/usr/bin" exec-path)


Termuxでプログラムがインストールされれば、それらにEmacsがアクセスできるようになる。


FAQのこのセクションでは、以前はTermuxからバイナリを実行するために環境変数`LD_LIBRARY_PATH'をセットするという誤った解説が提供されていた。実際にはTermuxの実行可能バイナリにはTermuxの共有ライブラリーのパスが埋め込まれており、Termuxのバイナリが実行される際のリンクプロセス中にインポートされる一連のライブラリーにたいして(逆も発生し得る)、別個に提供される`LD_LIBRARY_PATH`によるシステムライブラリー名の競合による干渉が原因の数多の奇妙なエラーが発生するのだ。


Termux(とそれを使用するようにビルドしたEmacs)はAndroid 7.0以降にしかインストールできないことをどうか忘れないで欲しい。


FREQUENTLY ANSWERED QUESTIONS


このEmacsポートのユーザーから寄せられるFAQにたいする解答のほとんどは、同時に配布されているEmacsおよびLispのリファレンスマニュアルに答えを見い出すことができるだろう。にも関わらず前述したドキュメントの存在を知らない人の利益のために、さまざまなFAQのリストここにまとめておいた。


1. どのパッケージをダウンロードすればいいの?


おそらく`emacs-3*.0.*0-29-arm64-v8a.apk`か`termux`ディレクトリーの同等パッケージだろう。あなたのスマホやタブレットが32ビットOSを実行している場合は、多分`emacs-3*.0.*0-16-armeabi-v7a.apk`。


2. どのパッケージをインストールすると、どのバージョンのEmacsがインストールされるの?


`emacs-30.0.90`という名前のパッケージは`emacs-30`ブランチから生成されており、最終的にはEmacs
30.1としてリリースされる。一方`emacs-31.0.50`という名前のパッケージは、すぐにはリリースされない開発ブランチから生成したパッケージ。


パッケージ名のバージョンと変数emacs-versionによってプリントされるバージョンは、プレテスト(訳注:
pretest、いわゆるベータ版のようなもの)のいずれかに相当するバージョンではあるがGitレポジトリのソースからビルドされており、プレテストのバージョンが同じであっても厳密にそのバージョンのソースからビルドされている保証はない。


3. どこで助けを得られるだろうか?


help-gnu-emacs@gnu.orgだ。


4. バグレポやpatchはどこに送付すれば?


bug-gnu-emacs@gnu.orgだ。


5. どうやってドキュメントやソースコード等にアクセスするの?


Androidアプリには3つの異なる種類のストレージにアクセスする権限を付与できる。


1つ目はアプリのデータディレクトリー。これはアプリにとってUnixホームディレクトリーに相当する役目をもっており、アクセスできるのはEmacs自身だけ。


2つ目は外部ストレージディレクトリー(/sdcardにある)。ここにアクセスするには、Emacsが明示的にアクセス権限を要求しなければならない。ファイルマネージャーアプリでは"内部ストレージ"として表示されるディレクトリー。


Android 11より前は、このディレクトリーへのアクセス権限をEmacsに与えるためにApp
Info設定メニューのPermissionsメニューからStorageという名前のオプションを有効にして行うことができた。Android
11では設定へのアクセス経路が変更されたので、SettingsにあるSpecial App Accessメニューから権限を与えなければならない。


オンラインに出回っている口上とは異なり、外部ストレージにアクセスするためにTermuxの変種をインストールする必要はない。とはいえ2つのアプリケーションでユーザーIDを共有した結果として、一方のアプリケーションにアクセス権限(外部ストレージへのアクセス権限もそのうちの1つ)が付与されれば、もう一方のアプリケーションもその権限を取得する。 


3つ目は他のアプリケーションたとえばNextcloud)によって提供されるストレージ。これはStorage Access
Frameworkを通じて提供される、/content/storageのサブディレクトリー配下にあるとてつもなく低速なストレージだ(Googleのドキュメントプロバイダー実装の失敗に祝福あれ)。これらのディレクトリーいずれかが利用可能になる前に`M-x
android-request-directory-access`を実行して、表示されたファイル選択パネルから権限を付与したいディレクトリーを選択しなければならない。


/contentディレクトリーはEmacs独自のファイル入出力プリミティブによって完全に実装されているので、サブプロセスがそのディレクトリーに含まれるファイルにアクセスすることはできない。そのディレクトリー内でサブプロセス生成を試みると、そのプロセスの実際の作業ディレクトリーは、実際にはEmacsのホームディレクトリーにセットされるだろう。これはEmacsとともに配布されるLispおよび補助ファイルを補助する/assetsディレクトリーにも適用される。


詳細についてはEmacsマニュアルの(emacs)Android Filesystem、および(emacs)Android Document
Providersを参照のこと。


6. わたしの.emacs、.emacs.d、init.elはどこにいった?


もちろん~/.emacsにある。


Emacsの構成をスマホ上のいわゆる内部ストレージにコピーして、すぐにEmacsから利用可能にすることはできない。なぜならこれはAndroidのセキュリティーモデルに起因する問題であり、Emacsのホームディレクトリーにアクセス可能な唯一のアプリがEmacsだけであるという理由による。


Emacsに内部ストレージへのアクセス権限を付与する方法に関する解答で示した手順にしたがい、それからそのディレクトリーにある構成ファイルをホームディレクトリーにコピーすればよい。


AndroidはEmacsのホームディレクトリーがあらかじめ決められた場所に配置されることを保証しないが、通常は/data/data/org.gnu.emacs/filesになるだろう。複数ユーザー(Unixユーザーではない;
Androidユーザーだ)のシステムでは、デバイスのオーナー以外のユーザーによってEmacsがインストールされた場合には、/data/user/配下のどこかに配置される可能性がある。


7. emacs、emacsclient、movemailといったバイナリはどこ?


簡単に言うと~/../lib。


長いバージョンで答えるとAndroidは実行可能ファイルをロードできる場所、それにインストールパッケージから抽出される実行可能ファイルの名前の両方に制限を課すので、Emacsは補助的な実行可能ファイルを共有ライブラリーに習った名前にしている。Emacsがインストールされると、AndroidはEmacsが起動時にホームディレクトリーの親ディレクトリーにある`lib`としてシンボリックリンクするプライベートディレクトリーにこれらの実行可能バイナリを抽出する。詳細については(elisp)Subprocess
Creation、および(emacs)Android Environmentを参照のこと。


これの実行可能バイナリの名前は比較的に安定しているので(近い将来においても)、`libemacsclient.so`、`libmovemail.so`等のようなハードコードされた名前ではなく`emacsclient-program-name`、`movemail-program-name`等といった名前を提供するために特に定義した変数を用いるほうがよい。このアドバイスにしたがっていれば将来、そして非Androidデバイスでもあなたのコードが実行され続けることが保証されるだろう。


`emacs`の場所についてはさらに複雑になる。実際には共有ライブラリーの`libemacs.so`こそが、EmacsのCコードすべてを含んでいるからだ。このコードはAndroidのファイルシステムおよびGUIインターフェイスを実装する一連のJava-コードにリンクされるまでは機能しない。これはアプリケーションからEmacsをオープンした実行時に、Android
JVMによって自動的に実行されるのだ。


`libandroid-emacs.so'はコマンドラインでのEmacsの開始において、正しい引数でJVMの呼び出しを試みるバイナリだ。Emacsがこの方法で開始された場合にはディスプレイ接続を作成できないというのは事実だが、予告なしに変更されるAndroid内部に依存する点こそがこのアプローチの最大の難点である。すべてのバージョンのAndroidで確実には動作しないこと、そしてOSにメジャーな変更が行われる度に後から修正する必要があるのは、この不適切な依存関係が理由なのだ。


そもそもEmacs内部でEmacsを実行するのではなく、このバイナリの必要性の排除こそがこの難問にたいする真の解決策だろう。


8. Where do I get more software?  (clang, git, python, etc.)


See (emacs)Android Software.  The `termux' directory holds versions of both
Termux and Emacs that share the same user ID and signing key.


9. The on-screen keyboard isn't displayed!  You must only use Emacs    with a physical keyboard!


The author of this port does not use a physical keyboard under Android.  He
uses AnySoftKeyboard for English input, and Fcitx


  https://github.com/fcitx5-android/fcitx5-android/


for CJK input.  With that misconception out of the way, there are at least
two reasons for asking this question.


The first is that you may have unthinkingly disabled the menu bar or tool
bar in keeping with an online Emacs introductory text, and now want to
perform operations which are then impossible without a keyboard.  This is a
very unwise decision on Android: any operation performed from a keyboard can
also be performed from the menu bar or tool bar (including M-x, which is
Edit -> Execute Command), making the use of a keyboard unnecessary.


With that in mind, and to save screen space, the keyboard is normally hidden
when the current window has selected a read-only buffer.  The second reason
for asking this question is wanting to always display the on-screen
keyboard; to do so, simply customize the option
`touch-screen-display-keyboard' to a non-nil value.  (Options -> Customize
Emacs, hint, hint.)


For more details and an in depth explanation of how Emacs treats touch
screen and on-screen-keyboard input, refer to (emacs)Touchscreens,
(emacs)On-Screen Keyboards, (elisp)Misc Events, and (elisp)Touchscreen
Events.


10. My package X that relies on reading raw key events / binding keys     globally doesn't work with an on screen keyboard!


This is because Android input methods rely on directly invoking Emacs's
buffer editing primitives, which is dubbed text conversion. Emacs tries to
implement features such as electric-indent, electric-pair and Auto-Fill
through analyzing the course of their edits after they take place.


Consequentially, Emacs doesn't receive raw key press events as you type into
the input method, your package doesn't work, and the text you type is
inserted directly into the current buffer in lieu of the events you meant to
send.


You can either fix these packages to disable text conversion through the
variable `overriding-text-conversion-style' or the buffer-local variable
`text-conversion-style', or disable text conversion globally by setting the
first variable.


See (elisp)Misc Events for further elucidations on the subject of text
conversion.


11. Point jumps to the start of the text after I type an opening     paren!  (And other problems with IMEs in Text or Prog Mode     derivatives.) This is probably a bug in your IME.  Emacs implements the Android input method interfaces to the letter, but Android's own implementation leaves much to be desired.


One extremely common transgression committed by input methods is to assume
that the `getExtractedText' IME request will always reply with the entire
contents of the buffer regardless of the number of characters the IME
requests, which is indeed the case when the editor is the Android TextView
widget.  In contrast, Emacs respects the size specified in the request, in
adherence with the documented behavior for that request.


An additional transgression is assuming that, since the result of that
request is always the entirety of the text buffer's contents, the caret
offset returned by the input method is the position of the insertion point.
In reality, the base of this offset is the start of the text returned.


Together, these two implementation mistakes result in many problematic input
methods misleading themselves into thinking that point is at the start of
the buffer.  After inserting a closing paren as part of their own
electric-pair features, such input methods often try to obtain the location
of the point and move to the last character prior to the closing paren.  But
what they think is the position of that character is actually the very
beginning of the buffer.


If the situation illustrated above does not appear consistent with the
behavior you witness from your IME, however, please send a bug report (with
M-x report-emacs-bug.)  In that report, mention the name and version number
of the IME you are using.


12. When I type in fundamental mode / a Custom buffer, the input     method goes haywire!


This is a bug in the IME.  Input methods don't just settle for implementing
text conversion incorrectly, they sometimes also forget to implement the
`TYPE_NULL' input mode that requires them to behave as plain keyboard
devices.


These bugs typically manifest as no text being inserted (since Emacs doesn't
provide an input connection when text conversion is disabled), as the Delete
key not working, or in any number of other ways.  Get a better input method,
and exhort your friends to do the same.


13. How do I display modifier keys in the tool bar?


Enable `modifier-bar-mode' and `tool-bar-mode'.  A small secondary tool bar
will be displayed together with the tool bar containing buttons that read
and modify subsequent events with each of the modifier keys understood by
Emacs.


When you tap one of these buttons, Emacs also displays the on-screen
keyboard and momentarily disables text conversion.  This enables you to type
key sequences containing modifier keys even in a Text or Prog Mode buffer
where text conversion is enabled.


14. How do I display the tool bar on the bottom of its frame?  I want     the buttons and modifier bar to be near my fingers as I type.


Although not specific to the Android port, the implementation of this
feature on non-GTK systems was motivated by one such request from an Android
port user.


Customize `tool-bar-position' to `bottom'.


15. How do I quit?  I can't type C-g.


Click the volume down button in rapid succession, which acts as a regular
C-g.


16. How do I open other files in Emacs?


Run `M-x server-start' (or better yet, place it in your initialization
files.)


When you try to open a text file, the system will display a dialog asking
for a program to run.  Select Emacs: emacsclient will be called to open the
file in question, or Emacs will be started with that file as an argument if
it's not already running.


17. What is the difference between this app and Emacs from Termux?


This app runs as a native Android GUI program, enabling it to take advantage
of input methods, document provider programs and suchlike, and its support
for touch screen input is superior, with most common gestures recognized
and/or transparently translated into mouse events.


Distributed Lisp and auxiliary files are stored entirely within the
application package itself, avoiding the need to use a separate package
manager to install Emacs updates.  These files are also loaded directly from
the app package, and so do not require a time-consuming extraction procedure
every time Emacs is updated before they can be used.


This app is also capable of employing ported Unix software from Termux as
well; see the top of this file, and moreover supports old Android releases
before 7.0, which Termux does not.


18. What's the difference between the builds provided here and those     offered by F-Droid?


F-Droid's version is an old snapshot of the Android port from Februrary;
although it has witnessed substantial improvement by comparison with the
version from February they previously distributed, it remains incomplete and
will always be absent bug fixes and new features present in the packages
housed here.


Their versions are also missing many of the dependencies packaged within the
builds provided here: GnuTLS, image libraries, tree-sitter, and so on.


19. Why can't I update from the F-Droid build to this one?


Because Android requires package updates to be signed with the same key used
to sign the existing installation, and F-Droid uses a signing key distinct
from the one included in the Emacs repository.


Back up your configuration and uninstall the F-Droid build prior to
installing any of the packages in this directory.


20. ``Set Default Font'' in the Options menu does not list the     fonts I have installed.


That menu is in truth a vestige from the early days of Emacs's graphics
support, when the only font ``backend'' was X, and programs could get away
with listing merely the fonts common to most X servers. When invoked under
Android, it produces a litany of fonts that are seldom really present on
Android.  Fonts should be configured through Customize or the
`set-frame-font' command instead.


21. Glyphs within Microsoft core fonts (Arial, Tahoma, and the like)     are misshapen or blurry.


Antiquated versions of these fonts exploit extensions and
implementation-specific behavior unique to the Microsoft Windows font scaler
that Emacs does not supply, as a result of which various glyph programs they
define go awry as they are executed to fit glyphs to the pixel grid.  The
solution is to update them to their latest revisions, as distributed with
recent releases of MS Windows.


In particular, such fonts expect the interpreter to grant them leave to
address nonexistent glyph points.  The MS scaler ignores offending
instructions, while Emacs terminates the program entirely.


22. Tool bar buttons are undersized.


Tool bar button margins do not increase to match the display density, which
produces buttons that appear smaller than expected on high-density output
devices, as featured by most Android phones today. Adjust the variable
`tool-bar-button-margin' to compensate.


23. B/W or grayscale displays are not detected, with the result that     colors applied by the likes of font-lock lack contrast.


This entry is relevant on tablets featuring "digital paper" displays,
monochromatic or grayscale displays being virtually unknown elsewhere.


Android not being designed for such applications, the display's visual class
is not reported to programs, and consequently you the user are responsible
for informing Emacs of the display color depth by means of the variable
`android-display-depth'; for a grayscale display, the optimal value is
anywhere between 2 and 8, where greater values correspond to more supported
grays, while the proper value for a monochrome display is 1.


Though this value controls color allocation choices, the display
capabilities reported to Lisp, and by extension colors selected during the
realization of faces, yet it does not affect font anti-aliasing or the
display of images, as the underlying surface provided to Emacs is always
color, with the driver converting anti-aliased text and color graphics into
grayscale or monochrome data for the glass instead.  Its purpose is rather
to enable users to activate the carefully curated palette for displays
wanting in color space or depth.


24. How/where do I obtain the corresponding source code to which I am     entitled under the terms of the GNU GPL?


Type:


  M-x describe-variable RET emacs-repository-version RET


within Emacs.  Next, download that revision from the Emacs Git repository
at:


  https://git.savannah.gnu.org/git/emacs.git


I also retain source code tarballs produced from the repository for the
binaries that are currently present on SourceForge.  Please contact me if
you require those.


25. Termux, its add-ons (or Emacs) won't install.


If you have downloaded and installed either the Termux-enabled Emacs, or
Termux itself, from this site, installation of upstream Termux app packages
will fail with a nondescript error message, as their signature will disagree
with those of the packages already installed.


You must either resign the packages you wish to install with the upstream
Emacs signing key:


  https://git.savannah.gnu.org/cgit/emacs.git/tree/java/emacs.keystore


or modify Android to disable its draconian signature verification, as with
an XPosed module such as:


  https://github.com/LSPosed/CorePatch


26. Something's missing from this FAQ!


If it's a subject not covered by the Android or Input nodes in the Emacs
manual, or the relevant portions of the Lisp reference manual, please report
a bug.  I will then update the manual and this FAQ as I see fit.

